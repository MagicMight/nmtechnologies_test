############################################################################################################
#
# 	Задача 1. Вариант 1 ("грязный", тк меняет словарь по ссылке)
# 	Чтобы решение соответствовало условию, что функция flatten от 
# 	одного аргумента, обход словаря сделан без использования рекурсии.
#
############################################################################################################


def flatten( d ):

	# Если аргумент не был передан
	if not d:
		return False

	if not any(d):
		return False

	# Условие завершения 
	needToCheckChildren = True
	
	while needToCheckChildren:
		needToCheckChildren = False

		# Ключи на удаление после обхода исходного словаря
		rm_keys = []

		# Словарь для добавления данных второго уровня после обхода исходного словаря
		add_dt = {}

		for key in d:

			# Если текущее значение является словарем (имеет вложенность)
			if type( d[key] ) is dict:

				# Перебираем дочерние элементы
				for subkey in d[key]:
					add_dt[ f'{key}.{subkey}' ] = d[key][subkey]

				# Добавляем ключ на удаление данных со вложенностью из исходного словаря
				rm_keys.append(key)

				# Отмечаем, что словарь был изменен
				needToCheckChildren = True

		# Удаляем ключи
		for key in rm_keys:
			d.pop(key)
		
		# Добавляем данные второго уровня
		for key in add_dt:
			d[key] = add_dt[key]

	print(d)
	return d


############################################################################################################
#
# 	Задача 1. Вариант 2 ("чистый", более оптимальный)
# 	В отличие от первого варианта исключает повторный перебор значений, не имеющих вложенности
#
############################################################################################################

def flatten2( d ):

	# Если аргумент не был передан
	if not d:
		return False
	
	if not any(d):
		return False

	
	# Создадим временный словарь
	temp = {}

	# Результирующий словарь
	res = {}

	# Инициализируем временный словарь начальными значениями
	for key in d:
		
		# Если значение является словарем, то добавляем во временный словарь
		if type( d[key] ) is dict:
			temp[ key ] = d[key]
		
		# В противном случае, записываем результирующий словарь
		else:
			res[ key ] = d[key]

	# Работаем над временным словарем, уменьшая максимальную вложенность на единицу с каждой итерацией
	while True:
		rm_keys = []
		add_vals = {}

		for key in temp:

			# Если у значения есть вложенность
			if type( temp[key] ) is dict:

					# Перебираем дочерние элементы
					for subkey in temp[key]:
						add_vals[ f'{key}.{subkey}' ] = temp[key][subkey]

			# Если вложенности нет, добавляем значение в результирующий словарь
			else:
				res[ key ] = temp[ key ]
			
			# Добавляем ключ на удаление данных со вложенностью из исходного словаря
			rm_keys.append(key)
		
		for key in rm_keys:
			temp.pop( key )
		
		for key in add_vals:
			temp[key] = add_vals[key]

		if not any( temp ):
			break
	
	print( res )
	return res




d = {
    "a": 5,
    "b": 6,
    "c": {
        "f": 9,
        "g": {
            "m": 17,
            "n": 3
        }
    }
}

# {'a': 5, 'b': 6, 'c.f': 9, 'c.g.m': 17, 'c.g.n': 3}
flatten2(d)
flatten(d)